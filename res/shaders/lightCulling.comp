#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : require

#define PIXELS_PER_TILE 16
#define MAX_NUM_LIGHTS_PER_TILE 128

struct Light {
    vec4 posAndIntensity;
    float radius;
    float pad[3];
};

layout(push_constant) uniform Constants {
    mat4 view;
    mat4 invP;
    mat4 proj;

    ivec2 screenSize;

    int lightCount;

    uint lightsBind;
    uint lightIndexBind;
    uint depthBind;
};

layout(binding = 1) buffer Lights { Light lights[]; }
lights[];

layout(binding = 1) buffer LightIndex { int lightIndex[]; }
lightIndex[];

layout(binding = 2) uniform sampler2D samplers[];

shared uint minDepthInt;
shared uint maxDepthInt;
shared uint visibleLightCount;
shared vec4 frustumPlanes[6];
shared int visibleLightIndices[MAX_NUM_LIGHTS_PER_TILE];

layout(local_size_x = PIXELS_PER_TILE, local_size_y = PIXELS_PER_TILE,
       local_size_z = 1) in;

void main() {
    ivec2 location = ivec2(gl_GlobalInvocationID.xy);
    ivec2 itemID = ivec2(gl_LocalInvocationID.xy);
    ivec2 tileID = ivec2(gl_WorkGroupID.xy);
    ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
    uint index = tileID.y * tileNumber.x + tileID.x;

    // Initialize shared global values for depth and light count
    if (gl_LocalInvocationIndex == 0) {
        minDepthInt = 0xFFFFFFFF;
        maxDepthInt = 0;
        visibleLightCount = 0;
    }

    barrier();

    // Step 1: Calculate the minimum and maximum depth values (from the depth
    // buffer) for this group's tile
    float maxDepth, minDepth;
    vec2 text = vec2(location) / screenSize;
    float depth = texture(samplers[depthBind], text).r;

    vec4 d = vec4(0, 0, depth, 1);
    d = invP * d;
    d /= d.w;

    depth = d.z;

    // Convert depth to uint so we can do atomic min and max comparisons between
    // the threads
    uint depthInt = floatBitsToUint(depth);
    atomicMin(minDepthInt, depthInt);
    atomicMax(maxDepthInt, depthInt);

    barrier();
    // Step 2: One thread should calculate the frustum planes to be used for
    // this tile
    if (gl_LocalInvocationIndex == 0) {
        // Convert the min and max across the entire tile back to float
        minDepth = uintBitsToFloat(minDepthInt);
        maxDepth = uintBitsToFloat(maxDepthInt);

        float x = tileID.x * PIXELS_PER_TILE;
        float y = tileID.y * PIXELS_PER_TILE;

        vec2 tile_scale = vec2(screenSize) * (1.0 / float(2 * PIXELS_PER_TILE));
        vec2 tile_bias = tile_scale - vec2(gl_WorkGroupID.xy);

        vec4 col1 = vec4(-proj[0][0] * tile_scale.x, proj[0][1], tile_bias.x,
                         proj[0][3]);
        vec4 col2 = vec4(proj[1][0], -proj[1][1] * tile_scale.y, tile_bias.y,
                         proj[1][3]);
        vec4 col4 = vec4(proj[3][0], proj[3][1], -1.0, proj[3][3]);

        frustumPlanes[0] = col4 + col1;
        frustumPlanes[1] = col4 - col1;
        frustumPlanes[2] = col4 - col2;
        frustumPlanes[3] = col4 + col2;
        frustumPlanes[4] = vec4(0.0, 0.0, -1.0, minDepth);
        frustumPlanes[5] = vec4(0.0, 0.0, 1.0, -maxDepth);

        for (int i = 0; i < 6; i++) {
            frustumPlanes[i] /= length(frustumPlanes[i].xyz);
        }
    }

    barrier();

    // Step 3: Cull lights.
    // Parallelize the threads against the lights now.
    // Can handle 256 simultaniously. Anymore lights than that and additional
    // passes are performed
    uint threadCount = PIXELS_PER_TILE * PIXELS_PER_TILE;
    uint passCount = (lightCount + threadCount - 1) / threadCount;
    for (uint i = 0; i < passCount; i++) {
        // Get the lightIndex to test for this thread / pass. If the index is >=
        // light count, then this thread can stop testing lights
        uint lightIndex = i * threadCount + gl_LocalInvocationIndex;
        if (lightIndex >= lightCount) {
            break;
        }

        vec4 position =
            vec4(lights[lightsBind].lights[lightIndex].posAndIntensity.xyz, 1);
        float radius = lights[lightsBind].lights[lightIndex].radius;

        // We check if the light exists in our frustum
        float distance = 0.0;
        for (uint j = 0; j < 6; j++) {
            distance = dot(view * position, frustumPlanes[j]) + radius;

            // If one of the tests fails, then there is no intersection
            if (distance <= 0.0) {
                break;
            }
        }

        // If greater than zero, then it is a visible light
        if (distance > 0) {
            // Add index to the shared array of visible indices
            uint offset = atomicAdd(visibleLightCount, 1);
            if (offset < MAX_NUM_LIGHTS_PER_TILE)
                visibleLightIndices[offset] = int(lightIndex);
        }
    }

    barrier();

    // One thread should fill the global light buffer
    if (gl_LocalInvocationIndex == 0) {
        uint offset =
            index *
            MAX_NUM_LIGHTS_PER_TILE;  // Determine bosition in global buffer
        for (uint i = 0; i < visibleLightCount && i < MAX_NUM_LIGHTS_PER_TILE;
             i++) {
            lightIndex[lightIndexBind].lightIndex[offset + i] =
                visibleLightIndices[i];
        }

        if (visibleLightCount != MAX_NUM_LIGHTS_PER_TILE) {
            // Unless we have totally filled the entire array, mark it's end
            // with -1 Final shader step will use this to determine where to
            // stop (without having to pass the light count)
            lightIndex[lightIndexBind].lightIndex[offset + visibleLightCount] =
                -1;
        }
    }
}